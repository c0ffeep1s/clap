+++
title = "Cookbook"
+++

For more usage examples see: 

[Quick Example](https://github.com/clap-rs/clap#quick-example)

[Using Derive Macros](https://github.com/clap-rs/clap#using-derive-macros)

[Using Builder Pattern](https://github.com/clap-rs/clap#using-builder-pattern)

[Using YAML](https://github.com/clap-rs/clap#using-yaml)


## A Basic Application
---

This example shows how to create a simple application with several arguments using usage strings.

The app has 5 possible **arguments** (`--help` and `--version` are auto-generated by clap):
- A config file: 
    + Uses `-c filename` or `--config filename`
- An output file
    + A positional argument (i.e. `$ myapp output_filename`)
- A debug flag
    + Uses `-d` or `--debug`
    + Allows multiple occurrences of such as `-dd` (for vary levels of debugging, as an example)
- A help flag (automatically generated by clap)
    + Uses `-h` or `--help` (Only autogenerated if you do NOT specify your own `-h` or `--help`)
- A version flag (automatically generated by clap)
    + Uses `-V` or `--version` (Only autogenerated if you do NOT specify your own `-V` or `--version`)

and 2 **subcommands** (`help` is auto-generated by clap)

- `test` (subcommands behave like their own apps, with their own arguments
    + Used by `$ myapp test` with the following arguments
        + A list flag
            + Uses `-l` (usage is `$ myapp test -l`
        + A help flag (automatically generated by clap)
            + Uses `-h` or `--help` (full usage `$ myapp test -h` or `$ myapp test --help`)
        + A version flag (automatically generated by clap)
            + Uses `-V` or `--version` (full usage `$ myapp test -V` or `$ myapp test --version`)
- `help` (automatically generated by clap because we specified a subcommand of our own)
    + Used by `$ myapp help` (same functionality as `-h` or `--help`)

### Code
---
Built with [latest stable 2.3.33](https://docs.rs/clap/2.33.3/clap/index.html)
```rust
extern crate clap;

use clap::{App, Arg};

fn main() {
    let matches = App::new("myapp")
        .version("1.0")
        .author("Me, <me@mail.com>")
        .about("Does awesome things")
        .arg(
            Arg::with_name("config")
                .short("c")
                .long("config")
                .value_name("FILE")
                .help("Sets a custom config file")
                .takes_value(true),
        )
        .arg(
            Arg::with_name("output")
                .help("Sets an optional output file")
                .index(1),
        )
        .arg(
            Arg::with_name("debug")
                .short("d")
                .long("debug")
                .multiple(true)
                .help("Turn debugging information on"),
        )
        .subcommand(
            App::new("test")
                .about("does testing things")
                .arg(Arg::with_name("list").short("l").help("lists test values")),
        )
        .get_matches();

    // You can check the value provided by positional arguments, or option arguments
    if let Some(o) = matches.value_of("output") {
        println!("Value for output: {}", o);
    }

    if let Some(c) = matches.value_of("config") {
        println!("Value for config: {}", c);
    }

    // You can see how many times a particular flag or argument occurred
    // Note: only flags can have multiple occurrences
    match matches.occurrences_of("debug") {
        0 => println!("Debug mode is off"),
        1 => println!("Debug mode is kind of on"),
        2 => println!("Debug mode is on"),
        _ => println!("Don't be crazy"),
    }

    // You can check for the existence of subcommands, and if found use their
    // matches just as you would the top level app
    if let Some(matches) = matches.subcommand_matches("test") {
        // "$ myapp test" was run
        if matches.is_present("list") {
            // "$ myapp test -l" was run
            println!("Printing testing lists...");
        } else {
            println!("Not printing testing lists...");
        }
    }
}
```
### Output Examples
---
`$ myapp help`

```
myapp 1.0
Me, <me@mail.com>
Does awesome things

USAGE:
    myapp [FLAGS] [OPTIONS] [output] [SUBCOMMAND]

FLAGS:
    -d, --debug      Turn debugging information on
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -c, --config <FILE>    Sets a custom config file

ARGS:
    <output>    Sets an optional output file

SUBCOMMANDS:
    help    Prints this message or the help of the given subcommand(s)
    test    does testing things
```

`$ myapp debug`

```
Value for output: debug
Debug mode is off
```

`$ myapp -dd` (2 occurrences)

```
Debug mode is on
```